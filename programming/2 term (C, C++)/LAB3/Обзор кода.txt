Функция main().Обзор:
	
	2234-2237. Объявляются переменные:
		Указатель на структуру ctx - контескт. Содержит все. Пока пустая. Лежит в glusterfs.h
		int ret - видимо, проверка, нужно ли выходить из программы. Существует, как элемент ctx.
		cmdlinestr = хз что. видимо, командная строка.
		*cmd - указатель на структуру _cmd_args. Лежит в glusterfs.h. Cкорее всего, там содержатся команды и опции (внутри комменты)ю Еще есть список структур опций транслятора.

	2239. gf_check_and_set_mem_acct. 
		Лежит в glusterfsd.c Проверяет, есть ли среди параметров командной строки "--no-mem-accounting". В зависимости от этого включиет или не включает глобальный "счетчик" памяти (gf_global_mem_acct). 

	Дальше "функция-конструктор" для ctx. Лежит в lib/ctx.c
		ret  в 0, создает еще 1 указатель на ctx(зачем?), выделяет память под ctx. Если "не ctx"(?!), ret  в -1 и выходим.
		Устанавливает счетчик памяти, такой же как глобальный. Инициализирует головы списков graphs и mempool_list структуры ctx. Устанавливаем какие-то "головы демона" в -1.
		Дальше проверка на взаимное исключения путей (наверное), если срабатывает - освобождаем память ctx. Выходим.

	Если ошибка создания структуры, выдаем сообщение "glusterfs 	context error"  - gf_msg. В этой функции проверяются 	дополнительно где именно ошибка, и выводится ( на самом деле там делается еще дохуя чего, но похуй.), там же пишутся логи, которые мы передаем. Вылетаем с ошибкой памяти

	Глобальная ctx указывает туда же, куда и ctx в main

	globals init - наверное инициализирует глобальные переменные. Внутри gf_log_globals_init - устанавливает значения переменных в ctx, связанные с логами, задает голову списка lru_queue структуры log структуры ctx. проверка, нужно ли выходить (pthread_once) - в аргумент выполняем функцию, которая ложит программу с ошибкой, если что-то не так. Если ошибка, кладем ее в логи, выходим из функции, в мэине определяется, что произошла ошибка, программа падает.


ТУТ КОД ЭДГАРА
-----------------------------
	ret = glusterfs_ctx_defaults_init (ctx);
	cmd_args_t *cmd_args NULL <-- Объявление командной строки (command line)

	struct rlimit lim = {0, }; <-- без понятие что значит
	ret = xlator_mem_acct_init (THIS, gfd_mt_end)  <-- функция для рета. THIS часто присваивает значения trav во всём коде этого модуля. Также от THIS->ctx что хз. Существует в 1262 строке while (trav) { ... } Возможно это нечто булевское.

	*** xlator.h и .c - это файлы, в которых находится большое количество трансляторов. ***
	
	затем встречается функция gf_msg (спустя время заметил, что я чёт глянул далеко, пока искал что за THIS и пусть, вдруг потом где встретится и станет понятнее). Порывшись, нашёл:

	Брать или не брать мьютекс здесь и в другом обработчике - gf_print_trace () - это большой вопрос. Принимая мьютекс в обработчик сигнала, это будет означать, что, если в процессе получается фатальный сигнал, а другой поток держит ctx-> log.log_buf_lock, чтобы, возможно, авторизировать сообщение в _gf_msg_internal (), нарушившая нить висит на замке мьютекса навсегда, не давая выход процесса. С другой стороны. не принимая мьютекс в обработчик сигнала вызовет его изменить lru_list буферированных сообщения Войти колоритный коррумпированной списка и потенциально привести к бесконечному каскаду SIGSEGVs и других вопросов повторно entrancy.

	очевидно, что это командные функции, для авторизации сообщения через консольку и при любом не правильном вводе - ошибка и критический вылет, но так как прога работает постоянно с командной строкой, то вылет хоть и происходит, но потом снова при перезапуске будут все настройки со всеми изменениями пользователя. Однако мьютекс упрощает жизнь просто останавливая процесс и не создавая вылета. Ошибка есть, но блокируется системой и остаётся незамеченной, кроме как сообщения в консольке, что что-то не так.

	Затем идёт весёлое продолжение: ret делается -1 и это нужно для того, чтобы если не произойдёт ни одна из всех следующих событий в функции, то будет ошибка. Это всё идёт через ctx-> и приписке ивента или эррора. Причём может быть только 1 событие после чего очередной goto out. 

	ret = parse_cmdline (argc, argv, ctx);
	По сути в моей части кода уже вставлена вставка с коментом, что она робит: 
	Если эта опция установлена, мы хотим распечатать и проверить файл, установить возвращаемое значение (код выхода в данном случае) и выйти.
	В этой функции очень много других функций проверок, например на доступ и если всё делается успешно - тогда , вроде, goto out с ретом = 1 (типо всё ОК). Если не так, выход из функции и вывод о наличии ошибки.


-----------------------------


	2270. Послле того как пропарсили аргументы командной строки, и чекнули какую-то хуйню, чекаем равен ли 1 cmd_exports, если равен, нужно cделать принтекспортс и выйти ( у принтекспортс есть комменты).  НУЖНО ПОСМОТРЕТЬ ЕЕ ПОДРОБНЕЕ

	Дальше начало работы с логами. Если лог фаил не задан, то он задается ф-ей gf_set_log_file_path. 
		gf_set_log_file_path: Внутри если аргументов не было, сразу выходим из функции, дальше, если есть точка монтирования (mount_point), то выделяем путь к файлу из этого аргумента. дальше что-либо записывается в логфаил функцией gf_asprintf и внутреними. Тоже самое с переменными volfile и volfile_Server.
	Установка пути может вернуть ошибку, тогда выводим ее. Дальше утсновка финальных параметров логов разными функциями. Все эти функции - обыкновенные "поля", с некоторыми проверками. После того, как все установлено, на сцене функция gf_log_init (видимо, уже включение логов, т.е создание логфайла.). 
		gf_log_init : Внутри всяческие проверки, которые выходят из функции, если что не так. Если все проверки пройдены и мы до сих пор внутри, создаем фаил, проверим, создался ли он, если не создался, выдаем ошибку, выходим. Потом закрываем фаил (ну а чего ему открытым висеть?). Присваиваем gf_log_logfilev значение logfile структуры log, выходим из функции.
	Возвращаемся в мэин.
	Дальше идут просто {} вообще хз, зачем. В них мы просто берем и аргументы командной строки записываем в ctx->cmdlinestr.

	gf_proc_dump_init() (неточный перевод - запуск свалки процессов) - внутри pthread_mutex_init (Нужно наконец с ней разобраться). Ну я вообще хз, не могу ее найти!

	create_fuse_mount(ctx) - тут начитается работа с системой(файловой)  fuse. нужно будет погуглить, что это. А теперь интересное: идет проверка, указан ли mount_point, если не указан, то выходим.  Дальше еще на какую-то ошибку проверка. Теперь выделяем память под транслятор master. Если не выделилась, вылетаем на метку ошибки. Присваеваем master->name - fuse функцией gf_strdup(выделяет память под новый массив чаров, копирует в него аргумент, возвращает новый массив).
	Если не получиловь - на еррор. 
		Устанавливаем тип транслятора set_type. Внутри функция set_type_virtual : там проверки, связанные с транслятором и типом. устанавливаем тип (если установился хорошо, возвращаем что все ок, если нет, то -1).
		Если что-то пошло не так, вызывается ф-я xlator_dynload (ДОВОЛЬНО БОЛЬШАЯ, ПОТОМ С НЕЙ РАЗБЕРЕМСЯ), выходим из ф-и.
	Если не установился, выдаем ошибку, идем на еррор.
	У транслятора есть своя структура ctx, присваеваем ей просто ctx. Инициализируем настройки транслятору функцией get_new_dict(внутри хз что). В общем дальше там установка всяких настроек fuse и тд, потом xlatur_init, в котором мы выделяем память под транслятор и пытаемся создать volume, если не получается - выдаем ошибку.

КОД ЭДГАРА
-----------------------

2305. Функция daemonize(). В ней идёт функция подгрузки файлов(pid_file через командную строку). Снова создаётся cmd_args и проверяется на наличие и отсутсвие в командной строке каких-то записей и если есть то по метке снова к файлу покачки и инжектирование таймера событий в log(?), а также установка СИГНАЛОВ (это еще одна из библиотек // это общая установка для всех потоков и блокировка эти сигналов без sigwaiter нитей, а также возврат к сигналам получаемых обрабаткой другими потоками, и установка обработчиков сигналов).

Затем ret = pipe (ctx->daemon_pipe), где сказано, что если в итоге рет не получит deamon_pipe, то "родитель не будет получать ждать для получения статуса ребёнка" pipe() был создан в xlator. Посмотрите в моей 1 части разбора кода, я писал немного про xlator. 

Также после этой функции идёт кейс, где рет либо -1, либо 0. Причём если -1, то происходит закрытие daemon_pipe[0], daemon_pipe[1] и вывод об ошибке. При 0 включается режим "ребёнка" и закрывается только daemon_pipe[0] и происходит "режим записи" (вполне возможно с консоли), а если рет не равен 0 и 1, то включается режим "родителя", где уже происходит только "чтение" и родитель ждёт статуса ребёнка, после чего выводит сообщение либо всё ок, либо ошибка (Я предполагаю, что именно тут могла быть и у нас с подключением ошибка, ведь сервер - это походу родитель, а ребёнок - клиенты)

2309. ctx->env = syncenv_new (0, 0, 0) Контекс-> Событие = функция(размер стека = 0, procmin = 0, procmax = 0) procmin и procmax я не нашёл, что означает, но эти переменные в syncenv_new() подвергаются проверкам. Глянув дальше, думаю это переведётся как Process Min\Max. Функция проделывает мало понятные штуки с newenv и procmin/max и в итоге возвращает return newenv; в конце функции. 

2316. Стоит приписка, что делать эту операцию строго после deamonize().
Происходит проверка cmd->global_timer_wheel (как я предполагаю это тот таймер, который, если вдруг истёк, то проделывает операцию 
ret = glusterfs_global_timer_wheel_init(ctx) ). Тут уже происходит подключение к следующей библиотеке tw.c\.h , причём это единственная функция в ней, в которой по видимому при истечении времени и не получении статус даётся ошибка, а при успехе дальше продолжаем работу в main-е. Функция тесно связана с библиотекой xlator и командой global_timer_wheel

2322. glusterfs_volumes_init() <-- функция, где происходит полное подключение к серверу от клиента. Подключаются проверки на наличие сокетов, volume файлов. Родитель (сервак) принимает пакет с размером рета (sizeof (ret)) в функции emancipate (освобождение) и ребёнок (клиент) "break free from the parent" (освобождается от родителя)

2326. ret = event_dispatch (ctx->event_pool); и попадаем в библиотеку event.c\.h , где имеется последняя маленькая функция об успехе видимо. Интересный факт: тут почти во всех функциях ивента встречается одна и тажа функция GF_VALIDATE_OR_GOTO ("event", event_pool, out); Мне кажется, в отчёте будет неплохо написать, что можно было б разрабом ее сократить и сэкономить много строк кода. Сделать более структурировано и было б понятнее и экономнее, что даёт оптимизацию и читаемость. 

-----------------------
Небольшие пометки по поводу кода: 
ret (с англ. Возвращаемое значение) играет большущую роль во всём мэйне и во всём коде в целом, так как с этой переменной происходит большое количество изменений и именно эта переменная (типа int) позволяет находить ошибки и выдавать пользователю. Также наряду с главным модулем glusterfsd есть очень большой бодуль xlator, который отвечает за транслятора - перевод (не знаю точно, но мне кажется не машинный код, а код, который вводит пользователь в консольку).
Также очень много кода идёт от cmd. 

+ кода: 
1) Есть много пометок, что делает функция в том или другом месте кода. Это очень полезно для понятия людям, которые читают код впервые и не знают, например, что он должен делать. 
2) Многие переменные имеют хорошо переводимые слова, что позволяет с лёгкостью понять, что будет происходить.
3) Для того, чтобы собрать код создано много майкфайлов, которые помогают использую несколько команд собрать всю программу
4) Эта программа хорошо написана, то есть содержит много проверок, а значит вероятность, что пользователь найдёт баг очень маленькая.
5) Программа проста в использовании и чрезвычайно полезна.
6) есть целые блоки кода с пояснениями, что будет делаться дальше во всём коде и обьяснение, что делает ret при разных значениях, например:
	success: 0 when successfully parsed
        failure: 1 when failed to parse one more more lines
                -1 when other critical errors (dlopen () etc)

- кода:
1) большое количество использования goto. Хоть в данной программе и чаще всего переход происходит на goto out, но это очень сбивает когда залазишь из функции в функцию и выбегаешь на out. 
2) иногда вполне уместно было бы приписать, что делает функция, в которой происходит абракодабра. Бывает функции делают волшебство, что требует обьяснений.

странности и особенности кода: 
1) при обьявлении функций разработчики придерживаются странного код стайла: 

int
print_exports_file (const char *exports_file)

/\
II
II
ведь можно было б написать всё в 1 строку (при поиске было бы проще ориентироваться, где идёт функция, а где она выполняется)

2)Как я понимаю код сервера и клиента - это один и тот же код, а значит, что разрабы довольно круто придумали совместить 2 в 1.

-----------------------

	
