Функция main().Обзор:
1)  ret = glusterfs_ctx_defaults_init (ctx);
	cmd_args_t *cmd_args NULL <-- Объявление командной строки (command line)

	struct rlimit lim = {0, }; <-- без понятие что значит
	ret = xlator_mem_acct_init (THIS, gfd_mt_end)  <-- функция для рета. THIS часто присваивает значения trav во всём коде этого модуля. Также от THIS->ctx что хз. Существует в 1262 строке while (trav) { ... } Возможно это нечто булевское.
	
	затем встречается функция gf_msg (спустя время заметил, что я чёт глянул далеко, пока искал что за THIS и пусть, вдруг потом где встретится и станет понятнее). Порывшись, нашёл:

	Брать или не брать мьютекс здесь и в другом обработчике - gf_print_trace () - это большой вопрос. Принимая мьютекс в обработчик сигнала, это будет означать, что, если в процессе получается фатальный сигнал, а другой поток держит ctx-> log.log_buf_lock, чтобы, возможно, авторизировать сообщение в _gf_msg_internal (), нарушившая нить висит на замке мьютекса навсегда, не давая выход процесса. С другой стороны. не принимая мьютекс в обработчик сигнала вызовет его изменить lru_list буферированных сообщения Войти колоритный коррумпированной списка и потенциально привести к бесконечному каскаду SIGSEGVs и других вопросов повторно entrancy.

	очевидно, что это командные функции, для авторизации сообщения через консольку и при любом не правильном вводе - ошибка и критический вылет, но так как прога работает постоянно с командной строкой, то вылет хоть и происходит, но потом снова при перезапуске будут все настройки со всеми изменениями пользователя. Однако мьютекс упрощает жизнь просто останавливая процесс и не создавая вылета. Ошибка есть, но блокируется системой и остаётся незамеченной, кроме как сообщения в консольке, что что-то не так.

	Затем идёт весёлое продолжение: ret делается -1 и это нужно для того, чтобы если не произойдёт ни одна из всех следующих событий в функции, то будет ошибка. Это всё идёт через ctx-> и приписке ивента или эррора. Причём может быть только 1 событие после чего очередной goto out. 


------------------

2) ret = parse_cmdline (argc, argv, ctx);
	По сути в моей части кода уже вставлена вставка с коментом, что она робит: 
	Если эта опция установлена, мы хотим распечатать и проверить файл, установить возвращаемое значение (код выхода в данном случае) и выйти.
	В этой функции очень много других функций проверок, например на доступ и если всё делается успешно - тогда , вроде, goto out с ретом = 1 (типо всё ОК). Если не так, выход из функции и вывод о наличии ошибки.


	
